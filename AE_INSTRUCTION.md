# Instructions to reproduce the evaluations of the paper

Here are the detailed instructions to perform the same experiments in our paper.

## Artifact claims

We claim that the results might differ from those in our paper due to various factors (e.g., cluster sizes, machines, OS, software packages, etc.). Nevertheless, we expect DMTree to still achieve similar performance (in normal operations) with Cassandra while significantly reducing storage overhead (i.e., our main results). In addition, to reduce the influence of cloud storage location, hardware requirement, complexity, and running time of the evaluation, we made some changes to the evaluation configurations.

## Cluster setup

* We require **six compute nodes** and **one memory node** in AE.
* We provide a server cluster consisting of 7 nodes (skv-node1 to skv-node7) for reproducing the experiments in our paper. One node, `skv-node7`, will be made available as the jump host for accessing the cluster and as the main node for running the reproduction scripts. The AEC can submit their SSH public key via the following document: XXX. Once we have added the key to the server, node7 can be accessed using the following command:`ssh -P 6672 aefast26@222.195.68.87`.
* We sincerely apologize that, due to limited cluster resources, we are unable to provide each AEC with an independent execution environment. To prevent potential conflicts caused by concurrent usage, we have adopted a document-based reservation system along with an exclusive access notification mechanism in the following steps, ensuring that only one AEC can run experiments at any given time. 
* Additionally, to avoid excessive redundant testing, we will indicate which experiments have already been executed and have results available. It will be up to the AEC to decide whether to rerun those parts.

## Environment setup

We provide scripts to set up the environment for the evaluation, including cloning the code repository and copying and compiling it across multiple cluster nodes. The scripts are tested on Ubuntu 20.04 LTS. 

**Step 1:** Run the following script on `skv-node7`, including cloning the code repository and copying and compiling it across multiple cluster nodes.

```shell
bash build_ae.sh
```

To prevent repeated compilation and concurrent execution from disrupting the established environment, we have implemented a tracking and checking mechanism for the environment setup status when running the `build_ae.sh` script:

- If the script has not been executed before and the code has not been copied or compiled, the script will be executed.
- If the script is currently being executed by another AEC, a message will prompt: ”`The script is already running, please wait.`“.
- If the script has already been executed, a message will prompt: "`Environment setup is complete, no need to run the script again.`"

## Evaluations

This section describes how to reproduce the evaluations in our paper. To simplify the reproduction process, we provide Ansible-based scripts to run all major experiments. The script will automatically run the experiments and generate the result logs. The scripts will take about 9~10 days to finish all the experiments.

- **We suggest running the scripts of Exp#0 first, which can reproduce the main results of our paper while including most of the functionality verification (i.e., achieve controllable storage saving compared with Cassandra; provide similar performance of different types of KV operations such as read, write, scan, and update)**.

### Note on the experiment scripts

These evaluation scripts require a long time to run. To avoid the interruption of the experiments, we suggest running the scripts in the background with `tmux`, `nohup`, `screen`, etc. In addition, please make sure that all scripts have been given execution permissions. You can do this according to the following example:

```shell
cd scripts
find . -type f -name "*.sh" -exec chmod +x {} \;
```

### Note on the evaluation results

The raw running log generated by the YCSB benchmark tool will be stored in the folder `${PathToELECTResultSummary}/` configured in the `scripts/settings.sh` file. The log file will be named with detailed configuration information, such as workload, KV number, operation number, etc.

To make the result easier to read, we provide the summarized result of each evaluation in the `scripts/exp/` folder and named `${ExpName}.log`. For example, the result of Exp#1 will be stored in `scripts/exp/Exp1-ycsb.log`.

For the **performance evaluation**, the result will be summarized in different ways according to the running round number of the experiment (defined in each of the experiment scripts by the variable `RunningRoundNumber`).

* If the running round number is 1, the result will be directly output as in the example shown below.

```shell
[Exp info] scheme: elect, workload: Write, KVNumber: 600000, OPNumber: 60000, KeySize: 24, ValueSize: 1000, ClientNumber: 16, ConsistencyLevel: ONE, ExtraFlag: 
Throughput (unit: op/s): 
Only one round: 9992.38
[READ] Average operation latency (unit: us):
Only one round: 1369.53
[READ] 99th percentile latency (unit: us):
Only one round: 1883.00
```

* If the running round number is between 1 and 5, the result will be output with the average, maximum, and minimum, as shown in the example below.

```shell
[Exp info] scheme: elect, workload: Write, KVNumber: 600000, OPNumber: 60000, KeySize: 24, ValueSize: 1000, ClientNumber: 16, ConsistencyLevel: ONE, ExtraFlag: 
Throughput (unit: op/s): 
Average: 9992.38, Min:  9753.433208489389, Max:  10231.330379889298
[READ] Average operation latency (unit: us):
Average: 1369.53, Min: 1355.774261, Max: 1383.292994
[READ] 99th percentile latency (unit: us):
Average: 1883.00, Min: 1823, Max: 1943
```

For the **storage overhead evaluation**, the result will be summarized based on the total, hot-tier, and cold-tier storage overhead. For example:

```shell
[Exp info] Scheme: elect, KVNumber: 100000000, KeySize: 24, ValueSize: 1000
Total storage overhead (unit: GiB): 185.90
Hot-tier storage overhead (unit: GiB): 134.10
Cold-tier storage overhead (unit: GiB): 51.80
```

For **other evaluations (i.e., Exp#3, 4, and 5)**, the result will be summarized similarly to the summarized performance results. Again, depending on the number of running rounds conducted, the output formats include options such as a single-round summary (run experiment with one round) or more comprehensive data sets featuring average, maximum, and minimum values (run experiment with 2~4 rounds), as well as average values with a 95% Student-T distribution confidence interval (run experiment more than five rounds). We provide examples of the summarized results of operation breakdown, recovery time cost, and resource usage in each related evaluation.

### Simple experiment (For quick verification)

#### Exp#0: Simple experiment (1 human-minutes + ~ 10 compute-hours)

We provide this simple experiment to verify our main experimental results quickly: **TODO: DMTree provides XXX...... similar performance compared to Cassandra while significantly reducing hot-tier storage overhead.** Specifically, we use 10M KV pairs and 1M KV operations (including read/write/update/scan, consistent with Exp2). This experiment will provide storage overhead (main results of Exp#1,2), performance of normal and degraded operations (main results of Exp#2), KV operation breakdown (main results of Exp#3), recovery time overhead when a single node fails (main results of Exp#4), and average resource utilization under load/normal/degraded conditions (main results of Exp#5). The summarized results will be printed on the screen after the evaluation and saved in the `scripts/exp/Exp0-simpleOverall.log` file.

You can run this simple experiment via the following command:

```shell
bash run_simple.sh
```

The results will be output in the file `simple_results.csv`. Here, we only show the title line and output sequence of each part. The specific result format of each part is as shown in the "Note on the evaluation results" above and the example of each specific experiment below.

```shell
Index,Workload,Total,Node1,Node2,Node4,Node5,Node6,Node7
dmtree,ycsb-c,52.27219999999999,9.14222,9.43155,8.89601,9.19277,6.2328,9.37685
dmtree,insert-only,26.19521,4.48305,4.46668,4.12491,4.34663,4.39217,4.38177
dmtree,update-only,27.82448,4.53334,4.80242,4.59759,4.71459,4.47005,4.70649
dmtree,scan-only,3.3973519999999997,0.565148,0.567675,0.564826,0.567579,0.565435,0.566689
fptree,ycsb-c,0.0,0.0,0.0,0.0,0.0,0.0,0.0
fptree,insert-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
fptree,update-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
fptree,scan-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
sherman,ycsb-c,0.0,0.0,0.0,0.0,0.0,0.0,0.0
sherman,insert-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
sherman,update-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
sherman,scan-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
smart,ycsb-c,0.0,0.0,0.0,0.0,0.0,0.0,0.0
smart,insert-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
smart,update-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
smart,scan-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
rolex,ycsb-c,0.0,0.0,0.0,0.0,0.0,0.0,0.0
rolex,insert-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
rolex,update-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
rolex,scan-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
dlsm,ycsb-c,0.0,0.0,0.0,0.0,0.0,0.0,0.0
dlsm,insert-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
dlsm,update-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
dlsm,scan-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
chime,ycsb-c,0.0,0.0,0.0,0.0,0.0,0.0,0.0
chime,insert-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
chime,update-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
chime,scan-only,0.0,0.0,0.0,0.0,0.0,0.0,0.0
```

如果卡住了，请取消脚本，运行如下脚本，清除各个服务器上运行的程序，并从卡住的地方尝试重新运行

- 协程判定退出的时候，会存在一些卡住的情况？还是server掉了

### Overall system analysis (Exp#1~5 in our paper)

#### Exp#1: Performance with YCSB core workloads (1 human minutes + ~ 20 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp1-ycsb.sh
```

#### Exp#2: Micro-benchmarks on KV operations (1 human-minutes + ~ 5 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp2-operations.sh
```

#### Exp#3: Performance breakdown (1 human-minutes + ~ 5 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp3-breakdown.sh
```

*Results:* These summaries are available in the `scripts/exp/` directory and can be found in the file named `Exp3-breakdown.log`. For example, the write operation breakdown result of ELECT will be output as in the example shown below. Note that the title for each metric is the same as the title in the paper.

```shell
[Breakdown info for Write] scheme: elect, KVNumber: 6000000, KeySize: 24, ValueSize: 1000
WAL (unit: ms/MiB):
Only one round: 388.95
MemTable (unit: ms/MiB):
Only one round: 686.65
Flushing (unit: ms/MiB):
Only one round: 200.79
Compaction (unit: ms/MiB):
Only one round: 1638.06
Transitioning (unit: ms/MiB):
Only one round: 259.84
Migration (unit: ms/MiB):
Only one round: 17.72
...
```

#### Exp#4: Full-node recovery (1 human-minutes + ~ 14 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp4-recovery.sh
```

*Results:* These summaries are available in the `scripts/exp/` directory and can be found in the file named `Exp4-recovery.log`.

* For ELECT, the recovery time is the time cost of retrieving the LSM-trees from the replication nodes and decoding the SSTables. The result will be output as in the example shown below.

```shell
[Exp info] scheme: elect, KVNumber: 6000000, KeySize: 24, ValueSize: 1000
Total recovery time cost (unit: s):
Average: 6653.00, Min: 6653, Max: 6653
Recovery time cost for retrieve LSM-trees (unit: s):
Average: 3442.00, Min: 3442, Max: 3442
Recovery time cost for decode SSTables (unit: s):
Average: 3211.00, Min: 3211, Max: 3211
```

* For Cassandra, the recovery time is the time cost of retrieving the SSTables from the replication only. The result will be output as in the example shown below.
  
```shell
[Exp info] scheme: cassandra, KVNumber: 6000000, KeySize: 24, ValueSize: 1000
Total recovery time cost (unit: s):
Only one round: 7515.00
```

#### Exp#5: Resource usage (1 human-minutes + ~ 5 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp5-resource.sh
```

*Results:* We summarize resource utilization as the 95th percentile of CPU usage, the 95th percentile of total memory overhead, total disk I/O, and total network overhead (bidirectional). In particular, we obtain the 95% percentile CPU usage based on the sum of the CPU usage of all nodes with the same timestamp and then calculate the average usage of each core (i.e., total usage/total number of cores). Therefore, the CPU usage results will be significantly affected by the differences in hardware configurations of different testbeds. The results will be output as in the example shown below.

```shell
[Resource usage with degraded operations] scheme: elect, KVNumber: 6000000, KeySize: 24, ValueSize: 1000, OPNumber: 600000
95%-percentile CPU Usage (%):
Only one round: 1.19
95%-percentile RAM Usage (GiB):
Only one round: 22.98
Total Disk I/O (GiB):
Only one round: 1.08
Total Network traffic (GiB):
Only one round: 202.38
```

### Parameter analysis (Exp#6~8 in our paper)

#### Exp#6: Impact of key and value sizes (1 human-minutes + ~ 40 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp6-kvSize.sh
```

#### Exp#7: Impact of storage-saving target (1 human-minutes + ~ 45 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp7-balanceParam.sh
```

#### Exp#8: Impact of erasure coding parameters (1 human-minutes + ~ 12 compute-hours)

The original experiment requires at least 12 nodes (1 client node, 10 server nodes, and 1 storage node). For the provided testbeds, limited by the number of available nodes, we adapt the changing range of erasure code K from 4~8 to 2~4. This result only verifies ELECT's adaptability to different K values.

*Running:*

```shell
bash scripts/exp/Exp8-ecParam.sh
```

### System setting analysis (Exp#9,10 in our paper)

#### Exp#9: Impact of read consistency level (1 human-minutes + ~ 5 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp9-consistency.sh
```

#### Exp#10: Impact of number of clients (1 human minutes + ~ 5 compute-hours)

*Running:*

```shell
bash scripts/exp/Exp10-clients.sh
```

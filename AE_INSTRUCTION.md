# Instructions to reproduce the evaluations of the paper

Here are the detailed instructions to perform the same experiments in our paper.

## Artifact claims

We claim that the results might differ from those in our paper due to various factors (e.g., cluster sizes, machines, OS, software packages, etc.). Nevertheless, we expect DMTree to still achieve similar performance (in normal operations) with Cassandra while significantly reducing storage overhead (i.e., our main results). In addition, to reduce the influence of cloud storage location, hardware requirement, complexity, and running time of the evaluation, we made some changes to the evaluation configurations.

## Artifact Overview



## Cluster setup

* We require **six compute nodes** and **one memory node** in AE.
* We provide a server cluster consisting of 7 nodes (skv-node1 to skv-node7) for reproducing the experiments in our paper. One node, `skv-node7`, will be made available as the jump host for accessing the cluster and as the main node for running the reproduction scripts. The AEC can submit their SSH public key via the following document: XXX. Once we have added the key to the server, node7 can be accessed using the following command:`ssh -P 6672 aefast26@222.195.68.87`.
* We sincerely apologize that, due to limited cluster resources, we are unable to provide each AEC with an independent execution environment. To prevent potential conflicts caused by concurrent usage, we have adopted a document-based reservation system along with an exclusive access notification mechanism in the following steps, ensuring that only one AEC can run experiments at any given time. 
* Additionally, to avoid excessive redundant testing, we will indicate which experiments have already been executed and have results available. It will be up to the AEC to decide whether to rerun those parts.

## Environment setup (~15 minutes)

We provide scripts to set up the environment for the evaluation, including cloning the code repository and copying and compiling it across multiple cluster nodes. The scripts are tested on Ubuntu 20.04 LTS. 

**Step 1:** Clone the code repository `aefast26`.

- Due to potential network fluctuations, the clone operation might require a few retries to complete successfully.

```shell
git clone https://github.com/muouim/aefast26.git
```

**Step 2:** Run the following script on `skv-node7`, including copying and compiling the code across multiple cluster nodes.

```shell
cd aefast26
bash build_ae.sh
```

To prevent repeated compilation and concurrent execution from disrupting the established environment, we have implemented a tracking and checking mechanism for the environment setup status when running the `build_ae.sh` script:

- If the script has not been executed before and the code has not been copied or compiled, the script will be executed.
- If the script is currently being executed by another AEC, a message will prompt: ”`The script is already running, please wait.`“
- If the script has already been executed, a message will prompt: "`Environment setup is complete, no need to run the script again.`"
- If AEC want to re-run the environment setup (some unexpected issues or something went wrong), please run `rm /tmp/build_ae.flag` to reset the environment setup status.

## Evaluations

This section describes how to reproduce the evaluations in our paper. To simplify the reproduction process, we provide Ansible-based scripts to run all major experiments. The script will automatically run the experiments and generate the result logs. The scripts will take about 9~10 days to finish all the experiments.

- **We suggest running the scripts of Exp#0 first, which can reproduce the main results of our paper while including most of the functionality verification (i.e., achieve controllable storage saving compared with Cassandra; provide similar performance of different types of KV operations such as read, write, scan, and update)**.

### Note on the experiment scripts

These evaluation scripts require a long time to run. To avoid the interruption of the experiments, we suggest running the scripts in the background with `tmux`, `nohup`, `screen`, etc. In addition, please make sure that all scripts have been given execution permissions. You can do this according to the following example:

```shell
cd scripts
find . -type f -name "*.sh" -exec chmod +x {} \;
```

### Note on the evaluation results

The raw running log generated by the YCSB benchmark tool will be stored in the folder `${PathToELECTResultSummary}/` configured in the `scripts/settings.sh` file. The log file will be named with detailed configuration information, such as workload, KV number, operation number, etc.

To make the result easier to read, we provide the summarized result of each evaluation in the `scripts/exp/` folder and named `${ExpName}.log`. For example, the result of Exp#1 will be stored in `scripts/exp/Exp1-ycsb.log`.

For the **performance evaluation**, the result will be summarized in different ways according to the running round number of the experiment (defined in each of the experiment scripts by the variable `RunningRoundNumber`).

* If the running round number is 1, the result will be directly output as in the example shown below.

```shell
[Exp info] scheme: elect, workload: Write, KVNumber: 600000, OPNumber: 60000, KeySize: 24, ValueSize: 1000, ClientNumber: 16, ConsistencyLevel: ONE, ExtraFlag: 
Throughput (unit: op/s): 
Only one round: 9992.38
[READ] Average operation latency (unit: us):
Only one round: 1369.53
[READ] 99th percentile latency (unit: us):
Only one round: 1883.00
```

For **other evaluations (i.e., Exp#3, 4, and 5)**, the result will be summarized similarly to the summarized performance results. Again, depending on the number of running rounds conducted, the output formats include options such as a single-round summary (run experiment with one round) or more comprehensive data sets featuring average, maximum, and minimum values (run experiment with 2~4 rounds), as well as average values with a 95% Student-T distribution confidence interval (run experiment more than five rounds). We provide examples of the summarized results of operation breakdown, recovery time cost, and resource usage in each related evaluation.

### Micro experiment (For quick verification)

#### Exp#11-12: Performance with Micro-benchmarks (~11 hours)

We provide this simple experiment to verify our main experimental results quickly: **TODO: DMTree provides XXX...... similar performance compared to Cassandra while significantly reducing hot-tier storage overhead.** Specifically, we use 10M KV pairs and 1M KV operations (including read/write/update/scan, consistent with Exp2). This experiment will provide storage overhead (main results of Exp#1,2), performance of normal and degraded operations (main results of Exp#2), KV operation breakdown (main results of Exp#3), recovery time overhead when a single node fails (main results of Exp#4), and average resource utilization under load/normal/degraded conditions (main results of Exp#5). The summarized results will be printed on the screen after the evaluation and saved in the `scripts/exp/Exp0-simpleOverall.log` file.

You can run this simple experiment via the following command:

```shell
bash run_simple.sh
```

Alternatively, you may consider running it in the background to avoid keeping the terminal window open for an extended period.

```shell
nohup bash run_simple.sh >run_simple.output 2>&1 &
```

To prevent repeated experiments and concurrent execution from disrupting the running experiments, we have implemented a tracking and checking mechanism for the simple experiment status when running the `run_simple.sh` script:

- If the script has not been executed before and the code has not been copied or compiled, the script will be executed.
- If the script is currently being executed by another AEC, a message will prompt: ”`The script is already running, please wait.`“
- If the script has already been executed, a message will prompt: "`Simple experiment is complete, no need to run the script again.`".
- If AEC want to re-run the simple experiment (some unexpected results or something wrong), please run `rm /tmp/simple_exp.flag` to reset the simple experiment status.

The results will be output in the file `simple_results_uniform.csv` and `simple_results_zipfian.csv`. 并且，我们绘制了柱状图`ycsb_uniform.pdf`和`ycsb_zipfian.pdf`.

Here, we only show the title line and output sequence of each part. The specific result format of each part is as shown in the "Note on the evaluation results" above and the example of each specific experiment below.

**simple_results_uniform.csv**

```
Index,Workload,Total,Node1,Node2,Node4,Node5,Node6,Node7
dmtree,ycsb-c,49.69586,8.3214,8.4839,8.39724,8.07157,8.22343,8.19832
dmtree,insert-only,26.372739999999997,4.4403,4.54854,4.17407,4.23682,4.60402,4.36899
dmtree,update-only,31.795920000000002,5.27421,5.29733,5.28315,5.34774,5.36419,5.2293
dmtree,scan-only,3.446158,0.572914,0.575549,0.572203,0.575403,0.57504,0.575049
fptree,ycsb-c,23.714789999999997,3.96312,3.97181,3.9583,3.96514,3.95907,3.89735
fptree,insert-only,13.52334,2.22194,2.25822,2.24564,2.27178,2.27274,2.25302
fptree,update-only,13.69716,2.28294,2.28727,2.27213,2.285,2.28717,2.28265
fptree,scan-only,2.654987,0.442648,0.442568,0.442031,0.442587,0.442552,0.442601
sherman,ycsb-c,9.81188,1.63574,1.63579,1.6328,1.63613,1.63577,1.63565
sherman,insert-only,5.981216,0.998046,0.998478,0.995345,0.999298,0.994832,0.995217
sherman,update-only,8.77102,1.46285,1.46291,1.45914,1.46308,1.46301,1.46003
sherman,scan-only,2.990589,0.498535,0.498477,0.497884,0.498578,0.49856,0.498555
smart,ycsb-c,48.28557,6.58257,9.18799,6.40419,8.93014,8.11444,9.06624
smart,insert-only,11.53051,1.71435,1.97921,1.96133,1.91434,2.05267,1.90861
smart,update-only,21.919349999999998,3.40476,3.71655,3.68659,3.6647,3.71745,3.7293
smart,scan-only,1.041088,0.173086,0.174587,0.172613,0.173529,0.174248,0.173025
rolex,ycsb-c,10.17066,1.69627,1.69603,1.68939,1.69627,1.69641,1.69629
rolex,insert-only,7.06437,1.17714,1.1776,1.177,1.17762,1.1775,1.17751
rolex,update-only,7.07585,1.17991,1.17994,1.17607,1.17998,1.18003,1.17992
rolex,scan-only,3.391118,0.565502,0.565522,0.563582,0.565517,0.565492,0.565503
dlsm,ycsb-c,18.36991,3.21127,2.92119,3.12477,3.025,3.02454,3.06314
dlsm,insert-only,4.715047,0.696512,0.883874,0.771909,0.779352,0.754986,0.828414
dlsm,update-only,23.23445,2.02157,2.0664,10.2327,2.1009,1.9844,4.82848
dlsm,scan-only,0.7661690000000001,0.132276,0.131247,0.118661,0.136749,0.130517,0.116719
chime,ycsb-c,31.38408,5.49949,3.81008,5.37363,5.50274,5.70717,5.49097
chime,insert-only,7.435649999999999,1.23096,1.24667,1.23782,1.24351,1.23578,1.24091
chime,update-only,18.45321,3.08806,2.99077,3.08156,3.09312,3.10516,3.09454
chime,scan-only,2.538482,0.422086,0.405211,0.419598,0.428614,0.43807,0.424903
```

**simple_results_zipfian.csv**

```shell
Index,Workload,Total,Node1,Node2,Node4,Node5,Node6,Node7
dmtree,ycsb-c,53.14693,9.03308,9.02831,8.79015,8.48879,8.91789,8.88871
dmtree,insert-only,26.38105,4.39275,4.49302,4.34678,4.31152,4.58725,4.24973
dmtree,update-only,29.02227,4.05761,4.94014,4.67556,4.98945,5.11801,5.2415
dmtree,scan-only,3.4390020000000003,0.572354,0.57411,0.570717,0.574015,0.57396,0.573846
fptree,ycsb-c,26.38646,4.38804,4.40993,4.39224,4.39771,4.40559,4.39295
fptree,insert-only,13.49708,2.24084,2.25663,2.24714,2.24957,2.25919,2.24371
fptree,update-only,14.77921,2.4547,2.46837,2.43277,2.46653,2.48649,2.47035
fptree,scan-only,2.6599909999999998,0.443154,0.443439,0.443034,0.443496,0.443498,0.44337
sherman,ycsb-c,9.80682,1.63447,1.63479,1.63307,1.63492,1.63469,1.63488
sherman,insert-only,5.982340999999999,0.998655,0.997865,0.995248,1.00002,0.995225,0.995328
sherman,update-only,1.897112,0.316186,0.315484,0.314938,0.315559,0.317741,0.317204
sherman,scan-only,3.014283,0.502456,0.50244,0.502058,0.502442,0.502452,0.502435
smart,ycsb-c,51.152860000000004,6.86627,9.21044,7.62574,8.77758,9.3365,9.33633
smart,insert-only,11.441650000000001,1.72969,1.95853,1.82413,2.00204,2.00797,1.91929
smart,update-only,24.898239999999998,3.67283,4.37875,3.72425,4.30601,4.41896,4.39744
smart,scan-only,1.049804,0.176254,0.175273,0.173624,0.174355,0.175623,0.174675
rolex,ycsb-c,11.33306,1.88964,1.88962,1.8852,1.8896,1.88975,1.88925
rolex,insert-only,7.06801,1.17844,1.17837,1.17615,1.1784,1.17833,1.17832
rolex,update-only,7.893560000000001,1.31615,1.31663,1.31142,1.31661,1.31707,1.31568
rolex,scan-only,3.3781749999999997,0.563232,0.563207,0.562062,0.563236,0.563217,0.563221
dlsm,ycsb-c,18.03255,3.36123,2.97891,2.93221,2.90981,2.89991,2.95048
dlsm,insert-only,5.184105,0.732869,1.00827,0.875831,0.789125,0.943514,0.834496
dlsm,update-only,40.14341,5.20028,5.67613,6.23658,7.04943,7.73673,8.24426
dlsm,scan-only,0.77451,0.134825,0.125945,0.124501,0.135181,0.12716,0.126898
chime,ycsb-c,40.37225,7.14846,5.33814,7.02093,6.86335,7.13929,6.86208
chime,insert-only,7.4409,1.23996,1.24562,1.22614,1.2461,1.23996,1.24312
chime,update-only,18.59494,3.1023,3.0827,3.09694,3.09088,3.1103,3.11182
chime,scan-only,2.718992,0.447759,0.455589,0.45241,0.453392,0.452061,0.457781
```

The output experimental results correspond to those presented in Figures 11 and 12 of the original paper. To enable quick experimental verification, we only provide the bottleneck performance—**i.e., the performance of each baseline under each workload at the maximum thread count**—which corresponds to the **red-boxed data points in the figures** and has been converted into bar charts.

As shown in the original overall experiment figures, the red boxes highlight the data produced by the simple experiment, representing the performance of each baseline under each workload at the maximum thread count.

<img src=".\AE_INSTRUCTION.assets\image-20250617173455219.png" alt="image-20250621112713219"  />

The experimental results in the file `simple_results_uniform.csv` are converted into bar charts, as shown in the figure.

<img src=".\AE_INSTRUCTION.assets\image-20250621112713219.png" alt="image-20250621112713219" style="zoom: 25%;" />

The experimental results in the file `simple_results_zipfian.csv` are converted into bar charts, as shown in the figure.

<img src=".\AE_INSTRUCTION.assets\image-20250621112758392.png" alt="image-20250621112758392" style="zoom:25%;" />

我们可以看到，DMTree实现了总体的最优性能（除了Zipfian的更新负载下，比dLSM要差，这也符合预期）



### YCSB experiment (Exp#14 in our paper)

#### Exp#14: Performance with YCSB core workloads (-20 hours)

***Running:***

You can run this simple experiment via the following command:

```shell
bash run_ycsb.sh
```

Alternatively, you may consider running it in the background to avoid keeping the terminal window open for an extended period.

```shell
nohup bash run_ycsb.sh >run_ycsb.output 2>&1 &
```

To prevent repeated experiments and concurrent execution from disrupting the running experiments, we have implemented a tracking and checking mechanism for the simple experiment status when running the `run_ycsb.sh` script:

- If the script has not been executed before and the code has not been copied or compiled, the script will be executed.
- If the script is currently being executed by another AEC, a message will prompt: ”`The script is already running, please wait.`“
- If the script has already been executed, a message will prompt: "`YCSB experiment is complete, no need to run the script again.`".
- If AEC want to re-run the simple experiment (some unexpected results or something wrong), please run `rm /tmp/ycsb_exp.flag` to reset the simple experiment status.

***Results:*** 

The results will be output in the file `ycsb_results_uniform.csv` and `ycsb_results_zipfian.csv`. Here, we only show the title line and output sequence of each part. The specific result format of each part is as shown in the "Note on the evaluation results" above and the example of each specific experiment below.

We summarize resource utilization as the 95th percentile of CPU usage, the 95th percentile of total memory overhead, total disk I/O, and total network overhead (bidirectional). In particular, we obtain the 95% percentile CPU usage based on the sum of the CPU usage of all nodes with the same timestamp and then calculate the average usage of each core (i.e., total usage/total number of cores). Therefore, the CPU usage results will be significantly affected by the differences in hardware configurations of different testbeds. The results will be output as in the example shown below.
